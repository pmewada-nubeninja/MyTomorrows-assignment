# Multi-Application Staging Environment Configuration

# ===========================
# 1. GLOBAL CONFIGURATION
# ===========================
global:
  environment: "staging"
  registry: "docker.io"
  imageTag: "latest"
  namespace: "my-app-staging"

namespace:
  name: my-app-staging
  create: true
  labels:
    environment: "staging"

environment: "staging"

# Shared infrastructure configuration
imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  automount: false
  annotations: {}
  name: ""

networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 5000
        - protocol: TCP
          port: 80
  egress:
    - to: []
      ports:
        - protocol: UDP
          port: 53
    - to: []
      ports:
        - protocol: TCP
          port: 443

rbac:
  enabled: true
  rules:
    - apiGroups: [""]
      resources: ["pods"]
      verbs: ["get", "list"]
    - apiGroups: [""]
      resources: ["configmaps"]
      verbs: ["get", "list"]

# Pod annotations and labels
podAnnotations: {}
podLabels: {}

# Security contexts
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 10001
  runAsGroup: 10001
  fsGroup: 10001

securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 10001
  runAsGroup: 10001
  capabilities:
    drop:
    - ALL

# Pod Disruption Budget for staging
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Pod Security Standards for staging
podSecurityStandards:
  enforce: "restricted"
  audit: "restricted"
  warn: "restricted"

# Additional volumes and mounts
volumes: []
volumeMounts: []
nodeSelector: {}
tolerances: []
affinity: {}

# ===========================
# 2. DEFAULT APP CONFIGURATION
# ===========================
# Default configuration applied to all applications
defaultApp:
  image:
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
  app:
    containerPort: 5000
  security:
    securityContext:
      runAsUser: 10001
      runAsGroup: 10001
      fsGroup: 10001
      runAsNonRoot: true
      fsGroupChangePolicy: "OnRootMismatch"
      supplementalGroups: []
    podSecurityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsUser: 10001
      runAsGroup: 10001
      runAsNonRoot: true
      capabilities:
        drop: ["ALL"]
        add: []

# ===========================
# 3. INDIVIDUAL APPLICATIONS
# ===========================
# Applications array - each app can have unique configuration
applications:
  - name: my-tomorrows-api
    enabled: true
    image:
      repository: cloudandparth/my-demo-app
      tag: "1.1" # Different version for staging
      pullPolicy: Always
    service:
      type: LoadBalancer # Use LoadBalancer for staging
      port: 80
      targetPort: 5000
    app:
      containerPort: 5000
    config:
      API_BASE_URL: "https://staging-api.example.com"
      LOG_LEVEL: "INFO" # Less verbose logging in staging
      MAX_CONNECTIONS: "20"
      SERVICE_NAME: "api-service"
    secrets:
      DB_PASSWORD: "YXBpX2RiX3N0YWdpbmdfcGFzc3dvcmQ=" # base64: api_db_staging_password
      SECRET_KEY: "YXBpX3N0YWdpbmdfc2VjcmV0X2tleQ==" # base64: api_staging_secret_key
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi
    healthChecks:
      livenessProbe:
        httpGet:
          path: /config
          port: 5000
        initialDelaySeconds: 30
        periodSeconds: 10
      readinessProbe:
        httpGet:
          path: /health
          port: 5000
        initialDelaySeconds: 5
        periodSeconds: 5
      startupProbe:
        httpGet:
          path: /
          port: 5000
        initialDelaySeconds: 10
        periodSeconds: 10
        failureThreshold: 30
    ingress:
      enabled: true
      host: staging-api.mytomorrows.com
      path: /api
      annotations:
        kubernetes.io/ingress.class: nginx
        nginx.ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
        nginx.ingress.kubernetes.io/rate-limit: "100"
        nginx.ingress.kubernetes.io/rate-limit-window: "1m"
        nginx.ingress.kubernetes.io/ssl-protocols: "TLSv1.2 TLSv1.3"
        nginx.ingress.kubernetes.io/ssl-ciphers: "ECDHE-RSA-AES128-GCM-SHA256,ECDHE-RSA-AES256-GCM-SHA384"
        cert-manager.io/cluster-issuer: letsencrypt-staging
      tls: true

  - name: my-tomorrows-admin
    enabled: true
    image:
      repository: nginx
      tag: "alpine"
      pullPolicy: IfNotPresent
    service:
      type: LoadBalancer
      port: 80
      targetPort: 80
    app:
      containerPort: 80
    config:
      API_ENDPOINT: "http://my-tomorrows-api-service.my-app-staging.svc.cluster.local"
      ENVIRONMENT: "staging"
      SERVICE_NAME: "admin-dashboard"
    secrets:
      ADMIN_SECRET: "YWRtaW5fc3RhZ2luZ19zZWNyZXQ=" # base64: admin_staging_secret
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 200m
        memory: 256Mi
    healthChecks:
      livenessProbe:
        httpGet:
          path: /config
          port: 80
        initialDelaySeconds: 30
        periodSeconds: 10
      readinessProbe:
        httpGet:
          path: /health
          port: 80
        initialDelaySeconds: 5
        periodSeconds: 5
      startupProbe:
        httpGet:
          path: /
          port: 80
        initialDelaySeconds: 10
        periodSeconds: 10
        failureThreshold: 30
    ingress:
      enabled: true
      host: staging-admin.mytomorrows.com
      path: /
      annotations:
        kubernetes.io/ingress.class: nginx
        nginx.ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
        nginx.ingress.kubernetes.io/rate-limit: "100"
        nginx.ingress.kubernetes.io/rate-limit-window: "1m"
        nginx.ingress.kubernetes.io/ssl-protocols: "TLSv1.2 TLSv1.3"
        nginx.ingress.kubernetes.io/ssl-ciphers: "ECDHE-RSA-AES128-GCM-SHA256,ECDHE-RSA-AES256-GCM-SHA384"
        cert-manager.io/cluster-issuer: letsencrypt-staging
      tls: true
    autoscaling:
      enabled: true
      minReplicas: 2
      maxReplicas: 5
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80

  - name: my-tomorrows-worker
    enabled: true # Third application - worker service
    image:
      repository: cloudandparth/my-demo-worker
      tag: "1.0"
      pullPolicy: Always
    service:
      type: ClusterIP # Internal service only
      port: 3000
      targetPort: 3000
    app:
      containerPort: 3000
    config:
      QUEUE_URL: "redis://redis.my-app-staging.svc.cluster.local:6379"
      WORKER_THREADS: "4"
      LOG_LEVEL: "INFO"
      SERVICE_NAME: "background-worker"
    secrets:
      WORKER_SECRET: "d29ya2VyX3NlY3JldF9zdGFnaW5n" # base64: worker_secret_staging
    resources:
      requests:
        cpu: 150m
        memory: 192Mi
      limits:
        cpu: 300m
        memory: 384Mi
    healthChecks:
      livenessProbe:
        httpGet:
          path: /health
          port: 3000
        initialDelaySeconds: 30
        periodSeconds: 10
      readinessProbe:
        httpGet:
          path: /ready
          port: 3000
        initialDelaySeconds: 5
        periodSeconds: 5
      startupProbe:
        httpGet:
          path: /startup
          port: 3000
        initialDelaySeconds: 15
        periodSeconds: 10
        failureThreshold: 30
    ingress:
      enabled: false # Worker doesn't need external access